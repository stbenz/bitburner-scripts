import { NodeStats, NS } from "@ns";

// don't spend more than 80% of money generated by hacknet
const gSpendRatio = 0.8;

// initial "generated" money to get started
const gInitialMoney = 100000;

// number of nodes to buy if FORMULAS.exe not bought yet
const gInitialNodes = 3;

// number of levels to buy if FORMULAS.exe not bought yet
const gInitialLevels = 50;

type Node = { idx: number, sts: NodeStats };

/**
 * get Generator for NodeStats
 * 
 * @param {NS} ns
 * @return {Generator<Node>}
 */
function* getNodesGenerator(ns: NS): Generator<Node> {
  const n = ns.hacknet.numNodes();
  for (let i = 0; i < n; i++) {
    yield { idx: i, sts: ns.hacknet.getNodeStats(i) };
  }
}

/**
 * get NodeStats as array
 * 
 * @param {NS} ns
 * @return {Node[]}
 */
function getNodes(ns: NS) {
  return Array.from(getNodesGenerator(ns));
}

type UpgradeType = "none" | "node" | "level" | "ram" | "cores";

class Upgrade {
  static none: Upgrade = new Upgrade("none", 0, 1, 0);

  type: UpgradeType;
  moneyGain: number;
  cost: number;
  nodeIndex: number;

  constructor(type: UpgradeType, moneyGain: number, cost: number, nodeIndex: number) {
    this.type = type;
    this.moneyGain = moneyGain;
    this.cost = cost;
    this.nodeIndex = nodeIndex;
  }

  static best(prev: Upgrade, cur: Upgrade): Upgrade {
    return cur.moneyGain / cur.cost > prev.moneyGain / prev.cost ? cur : prev
  }
}

/**
 * get NodeStats as array
 * 
 * @param {NS} ns
 * @return {IUpgrade} best upgrade
 */
function getBestUpgrade(ns: NS): Upgrade {
  const mult = ns.getHacknetMultipliers();
  const nodes = getNodes(ns);
  const upgradeGains = [];
  if (nodes.length < ns.hacknet.maxNumNodes()) {
    upgradeGains.push(new Upgrade(
      "node", 
      ns.formulas.hacknetNodes.moneyGainRate(1, 1, 1, mult.production),
      ns.hacknet.getPurchaseNodeCost(),
      nodes.length
    ));
  }
  if (nodes.length > 0) {
    const invalNode: Node = {
      idx: -1, 
      sts: {
        name: "",
        production: 0,
        timeOnline: 0,
        totalProduction: 0,
        level: Number.POSITIVE_INFINITY, 
        ram: Number.POSITIVE_INFINITY, 
        cores: Number.POSITIVE_INFINITY 
      }
    };

    const mln = nodes.reduce((a: Node, c: Node) => c.sts.level < a.sts.level ? c : a, invalNode);
    const mrn = nodes.reduce((a: Node, c: Node) => c.sts.ram < a.sts.ram ? c : a, invalNode);
    const mcn = nodes.reduce((a: Node, c: Node) => c.sts.cores < a.sts.cores ? c : a, invalNode);

    if (mln.sts.level < ns.formulas.hacknetNodes.constants().MaxLevel) {
      upgradeGains.push(new Upgrade(
        "level", 
        ns.formulas.hacknetNodes.moneyGainRate(mln.sts.level + 1, mln.sts.ram, mln.sts.cores, mult.production) - mln.sts.production,
        ns.hacknet.getLevelUpgradeCost(mln.idx),
        mln.idx
      ));
    } else {

    }
    if (mrn.sts.ram < ns.formulas.hacknetNodes.constants().MaxRam) {
      upgradeGains.push(new Upgrade(
        "ram",
        ns.formulas.hacknetNodes.moneyGainRate(mrn.sts.level, mrn.sts.ram * 2, mrn.sts.cores, mult.production) - mrn.sts.production,
        ns.hacknet.getRamUpgradeCost(mrn.idx),
        mrn.idx
      ));
    }
    if (mcn.sts.cores < ns.formulas.hacknetNodes.constants().MaxCores) {
      upgradeGains.push(new Upgrade(
        "cores",
        ns.formulas.hacknetNodes.moneyGainRate(mcn.sts.level, mcn.sts.ram, mcn.sts.cores + 1, mult.production) - mcn.sts.production,
        ns.hacknet.getCoreUpgradeCost(mcn.idx),
        mcn.idx
      ));
    }
  }
  return upgradeGains.reduce(Upgrade.best, Upgrade.none);
}


/** @param {NS} ns */
export async function main(ns: NS) {
  ns.disableLog("ALL");
  ns.setTitle("HACKNET");

  while (!ns.fileExists("Formulas.exe", "home")) {
    ns.print("Formulas.exe not found");
    while (ns.hacknet.numNodes() < gInitialNodes) {
      ns.hacknet.purchaseNode();
      await ns.sleep(500);
    }
    for (let i = 0; i < ns.hacknet.numNodes(); i++) {
      let level = ns.hacknet.getNodeStats(i).level;
      while (level < gInitialLevels) {
        const buy = Math.min(10, gInitialLevels - level);
        if (ns.hacknet.upgradeLevel(i, buy)) {
          level += buy;
        }
        await ns.sleep(500);
      }
    }
    await ns.sleep(60000);
  }

  while (true) {
    const generated = Math.max(gInitialMoney, ns.getMoneySources().sinceInstall.hacknet);
    let spent = ns.getMoneySources().sinceInstall.hacknet_expenses;
    if (spent > 0) {
      ns.print("ERROR: spent is positive: " + ns.formatNumber(spent));
      return;
    }

    let best = getBestUpgrade(ns);
    while (generated * gSpendRatio + spent - best.cost > 0) {
      if (best.cost < 0) {
        ns.print("ERROR: best is negative: " + ns.formatNumber(best.cost));
        return;
      }
      switch(best.type) {
        case "node":
          ns.print("INFO: buying new node for $" + ns.formatNumber(best.cost));
          if (ns.hacknet.purchaseNode() >= 0) {
            spent -= best.cost;
          } else {
            ns.print("ERROR: failed to purchase node");
            await ns.sleep(5000);
          }
          break;
        case "level":
          ns.print("INFO: upgrading node level for $" + ns.formatNumber(best.cost));
          if (ns.hacknet.upgradeLevel(best.nodeIndex)) {
            spent -= best.cost;
          } else {
            ns.print("ERROR: failed to upgrade level of node " + best.nodeIndex);
            await ns.sleep(5000);
          }
          break;
        case "ram":
          ns.print("INFO: upgrading node RAM for $" + ns.formatNumber(best.cost));
          if (ns.hacknet.upgradeRam(best.nodeIndex)) {
            spent -= best.cost;
          } else {
            ns.print("ERROR: failed to upgrade RAM of node " + best.nodeIndex);
            await ns.sleep(5000);
          }
          break;
        case "cores":
          ns.print("INFO: upgrading node cores for $" + ns.formatNumber(best.cost));
          if (ns.hacknet.upgradeCore(best.nodeIndex)) {
            spent -= best.cost;
          } else {
            ns.print("ERROR: failed to upgrade cores of node " + best.nodeIndex);
            await ns.sleep(5000);
          }
          break;
        default:
          ns.print("ERROR: invalid upgrade type: " + best.toString());
          return;
      }
      best = getBestUpgrade(ns);
      ns.print("g/s: $" + ns.formatNumber(generated) + " / $" + ns.formatNumber(-spent));
    }

    await ns.sleep(10000);
  }
}